# Inner functions in Clojure/Java

This article demonstrates how the Clojure compiler compiles a function
that contains another function inside of it.  In the example it is an
anonymous inner function created with `fn`, but the Clojure compiler
behaves similarly regardless of whether you use other mechanisms for
creating functions, such as the `#( ...)` syntax,
or [`letfn`](https://clojuredocs.org/clojure.core/letfn).

We will use a library called `clj-java-decompiler` that can take the
JVM byte code generated by the Clojure compiler, and decompile it into
Java source code that usually has the same behavior.

It is assumed that you have at least some familiarity with the Java
programming language.  You need not be a Java expert.  It is enough if
you are familiar with the syntax for defining a class with fields and
methods.

This demonstration uses the Clojure CLI tool command `clojure`.
Install instructions
are [here](https://clojure.org/guides/getting_started).

```bash
$ clojure -Sdeps '{:deps {com.clojure-goes-fast/clj-java-decompiler {:mvn/version "0.3.0"}}}'
```

Here are the input expressions evaluated in the REPL transcript below:

```clojure
(require '[clj-java-decompiler.core :refer [decompile]])

(decompile
 (defn my-transform [prefix input]
   (reduce (fn [xs x]
             (conj xs (str prefix x)))
           {} input)))
```

Note that the function `my-transform` calls `reduce`, and the first
parameter to `reduce` is an anonymous function defined using `fn`.

Some developers, when they first encounter such code, wonder: Is a new
function compiled and created each time the function `my-transform` is
called?

Read on and we will find out!

A REPL session that evaluates the expressions above is given below,
mingled with the outputs they produce.  I will break up the output
into two blocks, one colorized for Clojure code, but the last part
colorized for Java source code, since that is what the output of the
`decompile` macro is.

```clojure
user=> (require '[clj-java-decompiler.core :refer [decompile]])
nil

user=> (decompile
 (defn my-transform [prefix input]
   (reduce (fn [xs x]
             (conj xs (str prefix x)))
           {} input)))
```

```java
// Decompiling class: user$my_transform$fn__192
import clojure.lang.*;

public final class user$my_transform$fn__192 extends AFunction
{
    Object prefix;
    public static final Var const__0;
    public static final Var const__1;
    
    public user$my_transform$fn__192(final Object prefix) {
        this.prefix = prefix;
    }
    
    @Override
    public Object invoke(final Object xs, final Object x) {
        final IFn fn = (IFn)user$my_transform$fn__192.const__0.getRawRoot();
        final Object invoke = ((IFn)user$my_transform$fn__192.const__1.getRawRoot()).invoke(this.prefix, x);
        this = null;
        return fn.invoke(xs, invoke);
    }
    
    static {
        const__0 = RT.var("clojure.core", "conj");
        const__1 = RT.var("clojure.core", "str");
    }
}


// Decompiling class: user$my_transform
import clojure.lang.*;

public final class user$my_transform extends AFunction
{
    public static final Var const__0;
    
    public static Object invokeStatic(final Object prefix, final Object input) {
        return ((IFn)user$my_transform.const__0.getRawRoot()).invoke(new user$my_transform$fn__192(prefix), PersistentArrayMap.EMPTY, input);
    }
    
    @Override
    public Object invoke(final Object prefix, final Object input) {
        return invokeStatic(prefix, input);
    }
    
    static {
        const__0 = RT.var("clojure.core", "reduce");
    }
}
```

Let us first examine the last class definition.  The class is named
`user$my_transform`, which is a "munged" version of the Clojure name
`user/my-transform`, using only characters that are legal in a Java
class name.

The end of the class definition has a `static` block that initializes
the value of `const__0` to the Clojure var `clojure.core/reduce`.
This block of code is executed only once when the class is loaded
(i.e. shortly after the Clojure function is defined and thus also
compiled), not on every call to `my-transform`.

The bulk of the work is done in the `invokeStatic` method.  This takes
parameters `prefix` and `input` just as the Clojure function
`my-transform` does.

Let us take this method definition that appears in the code above:

```java
    public static Object invokeStatic(final Object prefix, final Object input) {
        return ((IFn)user$my_transform.const__0.getRawRoot()).invoke(new user$my_transform$fn__192(prefix), PersistentArrayMap.EMPTY, input);
    }
```

and rewrite it in a way that behaves the same, but makes each of the
steps smaller and easier to understand:

```java
    public static Object invokeStatic(final Object prefix, final Object input) {
        IFn reduce_fn = (IFn) user$my_transform.const__0.getRawRoot();
        Object inner_fn = new user$my_transform$fn__192(prefix);
        Object empty_map = PersistentArrayMap.EMPTY;
        return reduce_fn.invoke(inner_fn, empty_map, input);
    }
```

The first line calls the method `getRawRoot()` on the object stored in
`const__0`, which we saw above was initialized to the Clojure var
`clojure.core/reduce`.  This dereferences the var to get its current
value, every time `my-transform` is called.  This is quite quick -- if
you look at the definition of `getRawRoot` in the source file
`Var.java` of the Clojure implementation, you will see that it simply
returns the value of a field called `root` that is declared
`volatile`.

The second line constructs a new instance of the class
`user$my_transform$fn__192`.  The `192` part is just a counter value
maintained inside the Clojure compiler that is incremented when some
new class name is needed, to guarantee that the class names are
unique.

If we look at the definition of the constructor for class
`user$my_transform$fn__192` in the first class definition above,
copied here:

```java
    public user$my_transform$fn__192(final Object prefix) {
        this.prefix = prefix;
    }
```

we see that all it does is store a copy of a reference to the
parameter `prefix` in a field of the class.  So every time
`my-transform` is called, it is constructing a new instance of this
class `user$my_transform$fn__192`.  That does allocate enough memory
to hold that object, but the new object only has one `Object`
reference named `prefix`, so this is about as fast as constructing a
new JVM object can be.

If you do experiments with other inner functions, you will find that
when an inner function uses the value of parameters from an enclosing
function, the inner function's class constructor will take one
parameter for each of them, and that constructor will save a reference
to each of them in a field.

This is an implementation of
a [closure](https://en.wikipedia.org/wiki/Closure_(computer_programming)),
which is just a function bundled together with the necessary
information about its environment, so that there can be multiple
closures for a single function definition, each with a different set
of values that they have "captured" from their environment.

The third line is an assignment of a constant value to the local
variable `empty_map`.  That is there simply to give a name to that
constant.

The last line calls the `invoke` method on the object that is the
value of `reduce_fn`, which is the function that was created when
Clojure's function `clojure.core/reduce` was compiled.

So we can see that the inner function is not compiled on every call to
`my-transform`.  The Clojure compiler has created a separate class for
the inner function while it was compiling `my-transform`.  Every call
to `my-transform` does create a new (small) JVM object for the closure
that is the inner function plus any values that it uses from the
enclosing environment.

The JVM JIT compiler is thus able to generate native machine code for
either or both of these functions at run time.  Whether the JIT
compiler does so is up to how the JVM has been configured, how often
those functions are called, etc.


## Footnotes

The Clojure compiler transforms Clojure code into JVM byte code, with
no Java source code involved in the process at all.  It is possible in
some cases that the Clojure compiler can produce JVM byte code that a
Java compiler would not.  Thus while it is safe to trust the output of
a JVM byte code disassembler run on the output of the Clojure
compiler, it is more risky to trust the output of a
JVM-byte-code-to-Java-source-code decompiler, as is used here.  The
result may often be Java source code that is equivalent in behavior to
the JVM byte code, but in some cases it may be different.

You may wish to include the library `clj-java-decompiler` in a
`deps.edn` file of your project, or in the `~/.clojure/deps.edn` file
that is common for all projects of the same user account, as shown by
the `:decompile` alias in Sean Corfield's quite extensive example
`deps.edn`
file [here](https://github.com/seancorfield/dot-clojure/blob/develop/deps.edn).


## Variations

### Inner function that captures no values from its environment

This function has an inner function that is a "degenerate" closure,
i.e. a closure that does not capture any values from its lexical
environment.

Will the Clojure compiler recognize this case specially, and _not_
call `new` to create a JVM object every time the outer function is
called?

```clojure
(decompile
 (defn double-all [coll]
   (map (fn [x] (* 2 x)) coll)))
```

```java
// Decompiling class: user$double_all
import clojure.lang.*;

public final class user$double_all extends AFunction
{
    public static final Var const__0;
    
    public static Object invokeStatic(final Object coll) {
        return ((IFn)user$double_all.const__0.getRawRoot()).invoke(new user$double_all$fn__198(), coll);
    }
    
    @Override
    public Object invoke(final Object coll) {
        return invokeStatic(coll);
    }
    
    static {
        const__0 = RT.var("clojure.core", "map");
    }
}


// Decompiling class: user$double_all$fn__198
import clojure.lang.*;

public final class user$double_all$fn__198 extends AFunction
{
    @Override
    public Object invoke(final Object x) {
        final long x2 = 2L;
        this = null;
        return Numbers.multiply(x2, x);
    }
}
```

The answer: The generated code does call `new` to create a JVM object
every time the outer function is called.


### Inner function that is returned from the function it is created in

```clojure
(decompile
 (defn custom-reduce [map-fn reduce-fn reduce-init-val]
   (fn [coll] (reduce reduce-fn reduce-init-val (map map-fn coll)))))
```

```java
// Decompiling class: user$custom_reduce
import clojure.lang.*;

public final class user$custom_reduce extends AFunction
{
    public static Object invokeStatic(final Object map_fn, final Object reduce_fn, final Object reduce_init_val) {
        return new user$custom_reduce$fn__243(reduce_fn, reduce_init_val, map_fn);
    }
    
    @Override
    public Object invoke(final Object map_fn, final Object reduce_fn, final Object reduce_init_val) {
        return invokeStatic(map_fn, reduce_fn, reduce_init_val);
    }
}


// Decompiling class: user$custom_reduce$fn__243
import clojure.lang.*;

public final class user$custom_reduce$fn__243 extends AFunction
{
    Object reduce_fn;
    Object reduce_init_val;
    Object map_fn;
    public static final Var const__0;
    public static final Var const__1;
    
    public user$custom_reduce$fn__243(final Object reduce_fn, final Object reduce_init_val, final Object map_fn) {
        this.reduce_fn = reduce_fn;
        this.reduce_init_val = reduce_init_val;
        this.map_fn = map_fn;
    }
    
    @Override
    public Object invoke(final Object coll) {
        final IFn fn = (IFn)user$custom_reduce$fn__243.const__0.getRawRoot();
        final Object reduce_fn = this.reduce_fn;
        final Object reduce_init_val = this.reduce_init_val;
        final Object invoke = ((IFn)user$custom_reduce$fn__243.const__1.getRawRoot()).invoke(this.map_fn, coll);
        this = null;
        return fn.invoke(reduce_fn, reduce_init_val, invoke);
    }
    
    static {
        const__0 = RT.var("clojure.core", "reduce");
        const__1 = RT.var("clojure.core", "map");
    }
}
```

The inner function captures three values from its lexical environment,
and as expected when calling `new` to construct an instance of this
inner function's class, three parameters are passed, and all of their
values are saved in fields of the JVM object.

TODO: The decompiled Java code for the `invoke` method on the inner
function class has an assignment statement `this = null`.  I wonder
why that is there?  Is the `this` being assigned only to a reference
stored in a local variable of the object on which the `invoke` method
is being called, and assigning a value to it has no effect on any
other references that other code stores to this JVM object?

If so, it seems harmless, but unnecessary, to have this assignment
there.  Likely it is generated by the Clojure compiler as part of its
common policy of "locals clearing", to avoid holding on to references
to objects after their last use. to enable objects to become
unreferenced collectable garbage sooner than if these locals were not
cleared.
