# Inner functions in Clojure/Java

This article demonstrates how the Clojure compiler compiles a function
that contains another function inside of it.  In the example it is an
anonymous inner function created with `fn`, but the Clojure compiler
behaves similarly regardless of whether you use other mechanisms for
creating functions, such as the `#( ...)` syntax,
or [`letfn`](https://clojuredocs.org/clojure.core/letfn).

We will use a library called `clj-java-decompiler` that can take the
JVM byte code generated by the Clojure compiler, and decompile it into
Java source code that usually has the same behavior.

It is assumed that you have at least some familiarity with the Java
programming language.  You need not be a Java expert.  It is enough if
you are familiar with the syntax for defining a class with fields and
methods.

This demonstration uses the Clojure CLI tool command `clojure`.
Install instructions
are [here](https://clojure.org/guides/getting_started).

```bash
$ clojure -Sdeps '{:deps {com.clojure-goes-fast/clj-java-decompiler {:mvn/version "0.3.0"}}}'
```

Here are the input expressions evaluated in the REPL transcript below:

```clojure
(require '[clj-java-decompiler.core :refer [decompile]])

(decompile
 (defn my-transform [prefix input]
   (reduce (fn [xs x]
             (conj xs (str prefix x)))
           {} input)))
```

Note that the function `my-transform` calls `reduce`, and the first
parameter to `reduce` is an anonymous function defined using `fn`.

Some developers, when they first encounter such code, wonder: Is a new
function compiled and created each time the function `my-transform` is
called?

Read on and we will find out!

A REPL session that evaluates the expressions above is given below,
mingled with the outputs they produce.  I will break up the output
into two blocks, one colorized for Clojure code, but the last part
colorized for Java source code, since that is what the output of the
`decompile` macro is.

```clojure
user=> (require '[clj-java-decompiler.core :refer [decompile]])
nil

user=> (decompile
 (defn my-transform [prefix input]
   (reduce (fn [xs x]
             (conj xs (str prefix x)))
           {} input)))
```

```java
// Decompiling class: user$my_transform$fn__192
import clojure.lang.*;

public final class user$my_transform$fn__192 extends AFunction
{
    Object prefix;
    public static final Var const__0;
    public static final Var const__1;
    
    public user$my_transform$fn__192(final Object prefix) {
        this.prefix = prefix;
    }
    
    @Override
    public Object invoke(final Object xs, final Object x) {
        final IFn fn = (IFn)user$my_transform$fn__192.const__0.getRawRoot();
        final Object invoke = ((IFn)user$my_transform$fn__192.const__1.getRawRoot()).invoke(this.prefix, x);
        this = null;
        return fn.invoke(xs, invoke);
    }
    
    static {
        const__0 = RT.var("clojure.core", "conj");
        const__1 = RT.var("clojure.core", "str");
    }
}


// Decompiling class: user$my_transform
import clojure.lang.*;

public final class user$my_transform extends AFunction
{
    public static final Var const__0;
    
    public static Object invokeStatic(final Object prefix, final Object input) {
        return ((IFn)user$my_transform.const__0.getRawRoot()).invoke(new user$my_transform$fn__192(prefix), PersistentArrayMap.EMPTY, input);
    }
    
    @Override
    public Object invoke(final Object prefix, final Object input) {
        return invokeStatic(prefix, input);
    }
    
    static {
        const__0 = RT.var("clojure.core", "reduce");
    }
}
```

Let us first examine the last class definition.  The class is named
`user$my_transform`, which is a "munged" version of the Clojure name
`user/my-transform`, using only characters that are legal in a Java
class name.

The end of the class definition has a `static` block that initializes
the value of `const__0` to the Clojure var `clojure.core/reduce`.

The bulk of the work is done in the `invokeStatic` method.  This takes
parameters `prefix` and `input` just as the Clojure function
`my-transform` does.

Let us take this method definition:

```java
    public static Object invokeStatic(final Object prefix, final Object input) {
        return ((IFn)user$my_transform.const__0.getRawRoot()).invoke(new user$my_transform$fn__192(prefix), PersistentArrayMap.EMPTY, input);
    }
```

and rewrite it in a way that behaves the same, but makes each of the
steps a bit smaller and easier to understand:

```java
    public static Object invokeStatic(final Object prefix, final Object input) {
        IFn reduce_fn = (IFn) user$my_transform.const__0.getRawRoot();
        Object inner_fn = new user$my_transform$fn__192(prefix);
        Object empty_map = PersistentArrayMap.EMPTY;
        return reduce_fn.invoke(inner_fn, empty_map, input);
    }
```

The first line calls the method `getRawRoot()` on the object stored in
`const__0`, which we saw above was initialized to the Clojure var
`clojure.core/reduce`.  This dereferences the var to get its current
value, every time `my-transform` is called.  This is quite quick -- if
you look at the definition of `getRawRoot` in the source file
`Var.java` of the Clojure implementation, you will see that it simply
returns the value of a field called `root` that is declared
`volatile`.

The second line constructs a new instance of the class
`user$my_transform$fn__192`.  The `192` part is just a counter value
maintained inside the Clojure compiler that is incremented when some
new class name is needed, to guarantee that the class names are
unique.

If we look at the definition of the constructor for class
`user$my_transform$fn__192` in the first class definition above,
copied here:

```java
    public user$my_transform$fn__192(final Object prefix) {
        this.prefix = prefix;
    }
```

we see that all it does is store a copy of a reference to the
parameter `prefix` in a field of the class.  So every time
`my-transform` is called, it is constructing a new instance of this
class `user$my_transform$fn__192`.  That does allocate enough memory
to hold that object, but the new object only has one `Object`
reference named `prefix`, so this is about as fast as constructing a
new JVM object can be.

If you do experiments with other inner functions, you will find that
when an inner function uses the value of parameters from an enclosing
function, the inner function's class constructor will take one
parameter for each of them, and that constructor will save a reference
to each of them in a field.

This is an implementation of
a [closure](https://en.wikipedia.org/wiki/Closure_(computer_programming)),
which is just a function bundled together with the necessary
information about its environment, so that there can be multiple
closures for a single function definition, each with a different set
of values that they have "captured" from their environment.

The third line is an assignment of a constant value to the local
variable `empty_map`.  That is there simply to give a name to that
constant.

The last line calls the `invoke` method on the object that is the
value of `reduce_fn`, which is the function that was created when
Clojure's `clojure.core/reduce-fn` was compiled.

So we can see that the inner function is not compiled on every call to
`my-transform`.  The Clojure compiler has created a separate class for
the inner function while it was compiling `my-transform`.  Every call
to `my-transform` does create a new (small) JVM object for the closure
that is the inner function plus any values that it uses from the
enclosing environment.

The JVM JIT compiler is thus able to generate native machine code for
either or both of these functions at run time.  Whether the JIT
compiler does so is up to how the JVM has been configured, how often
those functions are called, etc.


## Footnotes

The Clojure compiler transforms Clojure code into JVM byte code, with
no Java source code involved in the process at all.  It is possible in
some cases that the Clojure compiler can produce JVM byte code that a
Java compiler would not.  Thus while it is safe to trust the output of
a JVM byte code disassembler run on the output of the Clojure
compiler, it is more risky to trust the output of a
JVM-byte-code-to-Java-source-code decompiler, as is used here.  The
result may often be Java source code that is equivalent in behavior to
the JVM byte code, but in some cases it may be different.

You may wish to include the library `clj-java-decompiler` in a
`deps.edn` file of your project, or in the `~/.clojure/deps.edn` file
that is common for all projects of the same user account, as shown by
the `:decompile` alias in Sean Corfield's quite extensive example
`deps.edn`
file [here](https://github.com/seancorfield/dot-clojure/blob/develop/deps.edn).
